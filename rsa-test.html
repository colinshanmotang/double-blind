<!doctype html>
<html>
<head>
  <title>Snarkjs client example</title>
</head>
<body>

  <h1>Snarkjs client example</h1>

   <textarea name="msg" cols="40" rows="5">msg</textarea>
  <textarea name="ssh-sig" cols="40" rows="5">ssh-sig</textarea>
  <textarea name="keylist" cols="40" rows="5">keylist</textarea>


  <button id="bGenProof"> Create proof </button>

  <textarea name="Input proof here" cols="40" rows="5" id="input-proof">proof</textarea>

  <textarea name="Input public inputs here" cols="40" rows="5" id="input-public">public</textarea>

  <button id="VerifyProof"> Verify proof </button>

  <!-- JS-generated output will be added here. -->
  <pre class="proof"> Proof: <br> <code id="proof"></code></pre>

  <pre class="proof"> Public inputs: <br> <code id="public"></code></pre>

  <pre class="proof"> Result: <br> <code id="result"></code></pre>


  <script src="snarkjs.min.js">   </script>


  <!-- This is the bundle generated by rollup.js -->
  <script type="module">
import {parseRSA_SHA2_512Signature, generatePKCS1BigInt} from './signature-processing.js';

const msgComponent = document.getElementById('msg');
const sshsigComponent = document.getElementById('ssh-sig');
const keylistComponent = document.getElementById('keylist');
const proofComponent = document.getElementById('proof');
const publicComponent = document.getElementById('public');
const resultComponent = document.getElementById('result');
const inputProof = document.getElementById('input-proof');
const inputPublic = document.getElementById('input-public');
//const inputInputs = document.getElementById('input-inputs');
const bGenProof = document.getElementById("bGenProof");
const vProof = document.getElementById("VerifyProof");

bGenProof.addEventListener("click", calculateProof);
vProof.addEventListener("click", verifyProof);

function bigint_to_registers(n, k, bi) {
    //k registers, of size n each
    let result = [];
    let bi_temp = bi;
    for(let i =0; i < k; i++){
        result.push((bi_temp % (1n << n)).toString());
        bi_temp = bi_temp / (1n << n);
    }
    return result;
}

async function calculateProof() {

    const signature_info = parseRSA_SHA2_512Signature(sshsigComponent.value);
    const keylist_array = keylistComponent.value.split(/\n/);
    let keylist_registers = [];
    for (let i = 0; i < keylist_array.length; i++){
        keylist_registers.push(bigint_to_registers(121n,34,parseSSHRSAPublicKey(keylist_array[i]).modulusBigInt));
    }
    
    const inputJson = {
        "msg":bigint_to_registers(121n,34,generatePKCS1BigInt(msgComponent.value, "file", "SHA-512", 512)),
        "key":bigint_to_registers(121n,34,signature_info.modulusBigInt),
        "sig":bigint_to_registers(121n,34,signature_info.signatureBigInt),
        "keylist":keylist_registers
    }
    const { proof, publicSignals } =
      await snarkjs.groth16.fullProve( inputJson, "rsa-test_js/rsa-test.wasm", "rsa-test_0001.zkey");

    proofComponent.innerHTML = JSON.stringify(proof, null, 1);

    publicComponent.innerHTML = JSON.stringify(publicSignals, null, 1);
    
}

async function verifyProof () {
    const vkey = await fetch("verification_key-rsa-test.json").then( function(res) {
        return res.json();
    });

    const publicSignals = JSON.parse(inputPublic.value);

    const proof = JSON.parse(inputProof.value);
    //console.log(vkey, publicSignals, proof);
    const res = await snarkjs.groth16.verify(vkey, publicSignals, proof);
    //console.log("success verify");

    resultComponent.innerHTML = res;
}

  </script>

</body>
</html>